"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadStaticAssets = exports.uploadStaticAssetsFromBuild = exports.deleteOldStaticAssets = exports.getAssetDirectoryFileCachePolicies = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const readDirectoryFiles_1 = __importDefault(require("./lib/readDirectoryFiles"));
const constants_1 = require("./lib/constants");
const s3_1 = __importDefault(require("./lib/s3"));
const pathToPosix_1 = __importDefault(require("./lib/pathToPosix"));
const getPublicAssetCacheControl_1 = __importDefault(require("./lib/getPublicAssetCacheControl"));
const getAssetDirectoryFileCachePolicies = (options) => {
    const { basePath, publicDirectoryCache, serverlessBuildOutDir } = options;
    const normalizedBasePath = basePath ? basePath.slice(1) : "";
    const assetsOutputDirectory = path_1.default.join(serverlessBuildOutDir, "assets");
    const buildIdPath = path_1.default.join(assetsOutputDirectory, normalizedBasePath, "BUILD_ID");
    const buildIdUpload = {
        path: buildIdPath,
        cacheControl: undefined
    };
    const nextStaticFiles = readDirectoryFiles_1.default(path_1.default.join(assetsOutputDirectory, normalizedBasePath, "_next", "static"));
    const nextStaticFilesUploads = nextStaticFiles.map((fileItem) => ({
        path: fileItem.path,
        cacheControl: constants_1.IMMUTABLE_CACHE_CONTROL_HEADER
    }));
    const nextDataFiles = readDirectoryFiles_1.default(path_1.default.join(assetsOutputDirectory, normalizedBasePath, "_next", "data"));
    const nextDataFilesUploads = nextDataFiles.map((fileItem) => ({
        path: fileItem.path,
        cacheControl: constants_1.SERVER_CACHE_CONTROL_HEADER
    }));
    const htmlPages = readDirectoryFiles_1.default(path_1.default.join(assetsOutputDirectory, normalizedBasePath, "static-pages"));
    const htmlPagesUploads = htmlPages.map((fileItem) => {
        const isDynamicFallback = /\[.*]/.test(fileItem.path);
        if (isDynamicFallback) {
            return {
                path: fileItem.path,
                cacheControl: constants_1.SERVER_NO_CACHE_CACHE_CONTROL_HEADER
            };
        }
        else {
            return {
                path: fileItem.path,
                cacheControl: constants_1.SERVER_CACHE_CONTROL_HEADER
            };
        }
    });
    const publicFiles = readDirectoryFiles_1.default(path_1.default.join(assetsOutputDirectory, normalizedBasePath, "public"));
    const staticFiles = readDirectoryFiles_1.default(path_1.default.join(assetsOutputDirectory, normalizedBasePath, "static"));
    const publicAndStaticUploads = [...publicFiles, ...staticFiles].map((fileItem) => ({
        path: fileItem.path,
        cacheControl: getPublicAssetCacheControl_1.default(fileItem.path, publicDirectoryCache)
    }));
    return [
        ...nextStaticFilesUploads,
        ...nextDataFilesUploads,
        ...htmlPagesUploads,
        ...publicAndStaticUploads,
        buildIdUpload
    ].map(({ cacheControl, path: absolutePath }) => ({
        cacheControl,
        path: {
            relative: path_1.default.relative(assetsOutputDirectory, absolutePath),
            absolute: absolutePath
        }
    }));
};
exports.getAssetDirectoryFileCachePolicies = getAssetDirectoryFileCachePolicies;
const uploadStaticAssetsFromBuild = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const { bucketName, credentials, basePath, publicDirectoryCache, nextConfigDir } = options;
    const files = getAssetDirectoryFileCachePolicies({
        basePath,
        publicDirectoryCache,
        serverlessBuildOutDir: path_1.default.join(nextConfigDir, ".serverless_nextjs")
    });
    const s3 = yield s3_1.default({
        bucketName,
        credentials: credentials
    });
    return Promise.all(files.map((file) => s3.uploadFile({
        s3Key: pathToPosix_1.default(file.path.relative),
        filePath: file.path.absolute,
        cacheControl: file.cacheControl
    })));
});
exports.uploadStaticAssetsFromBuild = uploadStaticAssetsFromBuild;
const uploadStaticAssets = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const { bucketName, basePath, nextConfigDir, nextStaticDir = nextConfigDir } = options;
    const s3 = yield s3_1.default({
        bucketName,
        credentials: options.credentials
    });
    const dotNextDirectory = path_1.default.join(nextConfigDir, ".next");
    const s3BasePath = basePath ? basePath.slice(1) : "";
    const buildStaticFiles = readDirectoryFiles_1.default(path_1.default.join(dotNextDirectory, "static"));
    const withBasePath = (key) => path_1.default.join(s3BasePath, key);
    const buildStaticFileUploads = buildStaticFiles.map((fileItem) => __awaiter(void 0, void 0, void 0, function* () {
        const s3Key = pathToPosix_1.default(withBasePath(path_1.default
            .relative(path_1.default.resolve(nextConfigDir), fileItem.path)
            .replace(/^.next/, "_next")));
        return s3.uploadFile({
            s3Key,
            filePath: fileItem.path,
            cacheControl: constants_1.IMMUTABLE_CACHE_CONTROL_HEADER
        });
    }));
    const pagesManifest = yield fs_extra_1.default.readJSON(path_1.default.join(dotNextDirectory, "serverless/pages-manifest.json"));
    const htmlPageUploads = Object.values(pagesManifest)
        .filter((pageFile) => pageFile.endsWith(".html"))
        .map((relativePageFilePath) => {
        const pageFilePath = path_1.default.join(dotNextDirectory, `serverless/${relativePageFilePath}`);
        return s3.uploadFile({
            s3Key: pathToPosix_1.default(withBasePath(`static-pages/${relativePageFilePath.replace(/^pages\//, "")}`)),
            filePath: pageFilePath,
            cacheControl: constants_1.SERVER_CACHE_CONTROL_HEADER
        });
    });
    const prerenderManifest = yield fs_extra_1.default.readJSON(path_1.default.join(dotNextDirectory, "prerender-manifest.json"));
    const prerenderManifestJSONPropFileUploads = Object.keys(prerenderManifest.routes).map((key) => {
        const pageFilePath = pathToPosix_1.default(path_1.default.join(dotNextDirectory, `serverless/pages/${key.endsWith("/") ? key + "index.json" : key + ".json"}`));
        return s3.uploadFile({
            s3Key: pathToPosix_1.default(withBasePath(prerenderManifest.routes[key].dataRoute.slice(1))),
            filePath: pageFilePath,
            cacheControl: constants_1.SERVER_CACHE_CONTROL_HEADER
        });
    });
    const prerenderManifestHTMLPageUploads = Object.keys(prerenderManifest.routes).map((key) => {
        const relativePageFilePath = key.endsWith("/")
            ? path_1.default.posix.join(key, "index.html")
            : key + ".html";
        const pageFilePath = pathToPosix_1.default(path_1.default.join(dotNextDirectory, `serverless/pages/${relativePageFilePath}`));
        return s3.uploadFile({
            s3Key: pathToPosix_1.default(withBasePath(path_1.default.posix.join("static-pages", relativePageFilePath))),
            filePath: pageFilePath,
            cacheControl: constants_1.SERVER_CACHE_CONTROL_HEADER
        });
    });
    const fallbackHTMLPageUploads = Object.values(prerenderManifest.dynamicRoutes || {})
        .filter(({ fallback }) => {
        return !!fallback;
    })
        .map((routeConfig) => {
        const fallback = routeConfig.fallback;
        const pageFilePath = pathToPosix_1.default(path_1.default.join(dotNextDirectory, `serverless/pages/${fallback}`));
        return s3.uploadFile({
            s3Key: pathToPosix_1.default(withBasePath(path_1.default.posix.join("static-pages", fallback))),
            filePath: pageFilePath,
            cacheControl: constants_1.SERVER_CACHE_CONTROL_HEADER
        });
    });
    const uploadPublicOrStaticDirectory = (directory, publicDirectoryCache) => __awaiter(void 0, void 0, void 0, function* () {
        const directoryPath = path_1.default.join(nextStaticDir, directory);
        if (!(yield fs_extra_1.default.pathExists(directoryPath))) {
            return Promise.resolve([]);
        }
        const files = readDirectoryFiles_1.default(directoryPath);
        return files.map((fileItem) => s3.uploadFile({
            filePath: fileItem.path,
            s3Key: pathToPosix_1.default(withBasePath(path_1.default.relative(path_1.default.resolve(nextStaticDir), fileItem.path))),
            cacheControl: getPublicAssetCacheControl_1.default(fileItem.path, publicDirectoryCache)
        }));
    });
    const publicDirUploads = yield uploadPublicOrStaticDirectory("public", options.publicDirectoryCache);
    const staticDirUploads = yield uploadPublicOrStaticDirectory("static", options.publicDirectoryCache);
    const allUploads = [
        ...buildStaticFileUploads,
        ...htmlPageUploads,
        ...prerenderManifestJSONPropFileUploads,
        ...prerenderManifestHTMLPageUploads,
        ...fallbackHTMLPageUploads,
        ...publicDirUploads,
        ...staticDirUploads
    ];
    return Promise.all(allUploads);
});
exports.uploadStaticAssets = uploadStaticAssets;
const deleteOldStaticAssets = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const { bucketName, basePath } = options;
    const normalizedBasePathPrefix = basePath ? basePath.slice(1) + "/" : "";
    const s3 = yield s3_1.default({
        bucketName,
        credentials: options.credentials
    });
    const buildId = yield s3.getFile({
        key: normalizedBasePathPrefix + "BUILD_ID"
    });
    if (buildId) {
        const deleteNextDataFiles = s3.deleteFilesByPattern({
            prefix: `${normalizedBasePathPrefix}_next/data`,
            pattern: new RegExp(`${normalizedBasePathPrefix}_next/data/.+/`),
            excludePattern: new RegExp(`${normalizedBasePathPrefix}_next/data/${buildId}/`)
        });
        const deleteStaticPageFiles = s3.deleteFilesByPattern({
            prefix: `${normalizedBasePathPrefix}static-pages`,
            pattern: new RegExp(`${normalizedBasePathPrefix}static-pages/.+/`),
            excludePattern: new RegExp(`${normalizedBasePathPrefix}static-pages/${buildId}/`)
        });
        yield Promise.all([deleteNextDataFiles, deleteStaticPageFiles]);
    }
});
exports.deleteOldStaticAssets = deleteOldStaticAssets;
